### @SpringBootApplication组合注解



#### 1 @Target({ElementType.TYPE})

1. 用于设定注解使用范围

2. **ElementType的用法**

   1. | 取值            | 注解使用范围                               |
      | --------------- | ------------------------------------------ |
      | METHOD          | 可用于方法上                               |
      | TYPE            | 可用于类或者接口上                         |
      | ANNOTATION_TYPE | 可用于注解类型上（被@interface修饰的类型） |
      | CONSTRUCTOR     | 可用于构造方法上                           |
      | FIELD           | 可用于域上                                 |
      | LOCAL_VARIABLE  | 可用于局部变量上                           |
      | PACKAGE         | 用于记录java文件的package信息              |
      | PARAMETER       | 可用于参数上                               |



#### 2 @Retention(RetentionPolicy.RUNTIME)

1. 指定注释要保留多长时间

2. 生命周期的划分
    1. RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；
    2. RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；
    3. RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；

   >  这3个生命周期分别对应于：Java源文件(.java文件) ---> .class文件 ---> 内存中的字节码。

3. 首先要明确生命周期长度 SOURCE < CLASS < RUNTIME ，所以前者能作用的地方后者一定也能作用。

#### 3 @Documented

1. Documented注解表明这个注解是由 javadoc记录



#### 4 @Inherited

1. **类继承关系中@Inherited的作用**
   1. 类继承关系中，子类会继承父类使用的注解中被@Inherited修饰的注解
2. **接口继承关系中@Inherited的作用**
   1. 接口继承关系中，子接口不会继承父接口中的任何注解，不管父接口中使用的注解有没有被@Inherited修饰
3. **类实现接口关系中@Inherited的作用**
   1. 类实现接口时不会继承任何接口中定义的注解



#### 5 @SpringBootConfiguration

##### @Target({ElementType.TYPE})
##### @Retention(RetentionPolicy.RUNTIME)
##### @Documented
##### @Configuration

1. @Configuration底层是含有@Component ，所以@Configuration 具有和 @Component 的作用。
2.  @Configuration可理解为用spring的时候xml里面的<beans>标签。
3. 实例化bean，交给spring进行托管



#### 6 @EnableAutoConfiguration

##### @Target({ElementType.TYPE})
##### @Retention(RetentionPolicy.RUNTIME)
##### @Documented
##### @Inherited
##### @AutoConfigurationPackage
1. @Import({Registrar.class})

   >  BeanDefinition 生成所有bean的配置信息
   

##### @Import({AutoConfigurationImportSelector.class})

1. AutoConfigurationImportSelector

   > 动态加载过滤

2. 过程

   1. 获取元数据配置
   2. 扫描META-INF/spring.factories文件
   3. maven中未配置的包不会加载
   4. 过滤，删除不存在的包



#### 7 @ComponentScan

1. @ComponentScan用于类或接口上主要是指定扫描路径，spring会把指定路径下带有指定注解的类自动装配到bean容器里。
2. 会被自动装配的注解包括@Controller、@Service、@Component、@Repository、@Configrature等等。
3. 注意点
   1. 在application.java文件中@SpringBootApplication会默认扫描当前包下及同级包目录
   
   2. 在application.java文件中@SpringBootApplication自带@ComponentScan会与@ComponentScan冲突
   
   3. @SpringBootApplication和@ComponentScan一起使用时，则不会扫描当前包下及同级包下的目录，使得@SpringBootApplication扫描失效，需要在@ComponentScan指定需要用到的包目录
   
   4. @ComponentScan 可以引用其他jar包目录，必须先通过maven引入
   
   5. 注意扫描可能有先后顺序
   
      

