### 定义

1. 再不改变原有对象的基础上，将功能附加到对象上，提供了比继承更具有弹性的替代方案



### 适用场景

1. 用于扩展一个类的功能，添加职责
2. 动态的给对象添加功能，这些功能可以再动态的撤销



### 装饰器实例

```java
// 基类接口
public abstract class Cake {
    public abstract String getMsg();

    public abstract int getPrice();
}

// 接口实现
public class BaseCake extends Cake {

    @Override
    public String getMsg() {
        return "蛋糕";
    }

    @Override
    public int getPrice() {
        return 10;
    }
}

// 基类装饰器
public class BaseCakeDecorator extends BaseCake{
    private BaseCake baseCake;

    // 必须创建构造函数
    public BaseCakeDecorator(BaseCake baseCake) {
        this.baseCake = baseCake;
    }

    public String getMsg() {
        return this.baseCake.getMsg();
    }

    public int getPrice() {
        return this.baseCake.getPrice();
    }
}

// 指定装饰器继承基类装饰器
public class BaseCakeWithAppleDecorator extends BaseCakeDecorator {
    public BaseCakeWithAppleDecorator(BaseCake baseCake) {
        super(baseCake);
    }

    public String getMsg() {
        return super.getMsg() + "1个苹果";
    }

    public int getPrice() {
        return super.getPrice() + 1;
    }
}

// 指定装饰器继承基类装饰器
public class BaseCakeWithEggDecorator extends BaseCakeDecorator {
    public BaseCakeWithEggDecorator(BaseCake baseCake) {
        super(baseCake);
    }

    public String getMsg() {
        return super.getMsg()  + "1个鸡蛋";
    }

    public int getPrice() {
        return super.getPrice() + 5;
    }
}

public class Test {
    public static void main(String[] args) {
        BaseCake baseCake = new BaseCake();
        baseCake = new BaseCakeWithEggDecorator(baseCake);
        baseCake = new BaseCakeWithAppleDecorator(baseCake);
        System.out.println(baseCake.getMsg()+ "总价，" + baseCake.getPrice());
    }
}
```



### 实现

1. inputStream
2. bufferInputStream
3. bufferReader
4. spring transationAwareCacheDecorator
5. mybatis Cache



### 与其他设计模式区别

1. 装饰器是一种特殊的静态代理模式
2. 装饰器强调自身功能的扩展
3. 代理强调代理过程的控制



### 优点

1. 使继承的有利补充，比继承灵活，不改变原有对象的情况下动态的给一个对象扩展，即插即用
2. 不同的装饰器进行排列组合，可以实现不同的效果
3. 遵循开闭原则



### 缺点

1. 会出现更多的代码，更多的类，增加程序的复杂性
2. 动态装饰，多层装饰会更复杂