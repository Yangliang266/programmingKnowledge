### 定义

> 对象池的一种实现，对象池可以避免不停的创建对象和销毁多个对象，消耗性能
>
> 共享细粒度对象，将多个对同一对象的访问集中起来



### 适用场景

1. 系统底层开发，解决系统系统性能问题
2. 系统有大量相似对象，需要缓冲池的场景



### 享元模式实例

```java
public interface Ticket {
    void showInfo(String bunk);
}

public class TrainTicket implements Ticket {
    private String from;
    private String to;
    private int price;

    public void setFrom(String from) {
        this.from = from;
    }

    public void setTo(String to) {
        this.to = to;
    }

    public TrainTicket(String from, String to) {
        this.from = from;
        this.to = to;
    }

    @Override
    public void showInfo(String bunk) {
        this.price = new Random().nextInt(500);
        System.out.println(from + "->" + to + ":" + bunk + "价格:" + this.price);
    }
}

// 配合工厂模式使用，注重资源的重复使用
public class TicketFactory {
    public static Map<String,Ticket> pool = new HashMap<String, Ticket>();

    public static Ticket queryTicket(String from, String to) {
        String key = from + "->" + to;
        if (pool.containsKey(key)) {
            System.out.println("使用缓存" + key);
            return pool.get(key);
        }
        System.out.println("首次使用对象：" + key);
        Ticket ticket  =new TrainTicket(from,to);
        pool.put(key,ticket);
        return ticket;
    }

    public static void main(String[] args) {
        Ticket ticket = TicketFactory.queryTicket("南通","上海");
        ticket.showInfo("硬座");
        ticket = TicketFactory.queryTicket("南通","上海");
        ticket.showInfo("软座");
        ticket = TicketFactory.queryTicket("南通","海南");
        ticket.showInfo("卧铺");
        ticket = TicketFactory.queryTicket("南通","海南");
        ticket.showInfo("硬座");
    }
}
```



### 与其他设计模式区别

1. 代理
   1. 享元模式使一对多，注重资源的重复利用
   2. 代理是一对一，注重增强
2. 配合工厂模式使用
3. 使用单例创建，避免多个对象的创建



### 应用

1. String 
2. Integer 超过127进入cache模式
3. LongCache
4. ObjectPool



### 优点

1. 减少对象的创建，降低内存的使用，提高效率，减少内存之外的其他资源的使用



### 缺点

1. 关注内外部状态，关注线程安全
2. 系统程序的逻辑复杂化



### 特点

1. 内部
   1. 不随环境的改变而改变
2. 外部
   1. 可以有多种状态，随环境的改变而改变，比如是否被回收，是否正在使用等等