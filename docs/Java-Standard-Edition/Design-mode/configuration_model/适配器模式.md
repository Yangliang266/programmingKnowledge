### 定义

1. > 将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作



### 适用场景

1. 已经存在的类，它的方法和需求不匹配
2. 随着软件的升级及维护而产生的解决方案



### 实例

```java 
// 原有类
public class Base220 {
    public int output(){
        return 220;
    }
}

// 继承模式 不满足最少知道原则
public class Base5Adapt extends Base220 {

    protected int output5v() {
        return output() / 5;
    }
}

public class Base10Adapt extends Base220 {

    protected int output5v() {
        return output() / 10;
    }
}

public static void main(String[] args) {
    Base10Adapt base10Adapt = new Base10Adapt();
    base10Adapt.output10();
    // 也可调用之前类的方法
    base10Adapt.output();

    Base5Adapt base5Adapt = new Base5Adapt();
    base5Adapt.output5();
     // 也可调用之前类的方法
    base5Adapt.output();
}

// 接口模式 
// 当适配类过多时，可用，不满足单一职责原则，接口隔离原则
public interface Base5v {
    int output5();

    int output10();
}

public class Base5Adapt implements Base5v {
    @Override
    public int output5() {
        return 220 / 5;
    }

    @Override
    public int output10() {
        return 220 / 10;
    }
}

 public static void main(String[] args) {
     BaseAdapt baseAdapt = new BaseAdapt();
     baseAdapt.output5();
     baseAdapt.output10();
 }

// 组合模式 满足最少知道原则
public class Base5Adapt {
    private Base220 base220;

    public Base5Adapt(Base220 base220) {
        this.base220 = base220;
    }

    protected int output5() {
        return base220.output() / 5;
    }
}

public class Base10Adapt {
    private Base220 base220;

    public Base10Adapt(Base220 base220) {
        this.base220 = base220;
    }

    protected int output5() {
        return base220.output() / 10;
    }
}


public static void main(String[] args) {
        Base220 base220 = new Base220();
        Base5Adapt base5Adapt = new Base5Adapt(base220);
        base5Adapt.output5();

        Base10Adapt base10Adapt = new Base10Adapt(base220);
        base10Adapt.output10();
    }

```





### 应用

1. spring aop - advisorAdapt
2. spring mvc - handerAdapt



### 优点

1. 提高类的透明性和复用，现有的类不需要改变

2. 目标类和适配器解耦，提高程序的可扩展性

3. 符合开闭原则

   

### 缺点

1. 增加系统的复杂性
2. 增加代码阅读难度