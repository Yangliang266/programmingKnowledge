### 定义

> 一种一对多的依赖关系，一个主题对象可以被多个观察者同时监听，使得每当主题对象状态改变时，所有依赖它的对象都会得到通知并且自动更新

> 使观察者和被观察者解耦



### 适用场景

1. 当一个模型包含两方免得内容，其中一方面依赖于另一个方面
2. 一个或者多个对象的变化依赖于另一个对象的变化
3. 类似广播机制的功能，无需直到具体的收听者，只需分发广播，感兴趣的对象会自动接受该广播
4. 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知



### 实例

1. 

```java
public class Event {
    // 事件源，由谁发出
    private Object source;

    // 事件触发，通知观察者
    private Object target;

    // 观察者给的回应
    private Method callback;

    // 事件的名称
    private String trigger;

    // 事件的触发时间
    private long time;

    public Event(Object target, Method callback) {
        this.target = target;
        this.callback = callback;
    }

    public Object getSource() {
        return source;
    }

    public Event setSource(Object source) {
        this.source = source;
        return this;
    }

    public Object getTarget() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    public Method getCallback() {
        return callback;
    }

    public void setCallback(Method callback) {
        this.callback = callback;
    }

    public String getTrigger() {
        return trigger;
    }

    public Event setTrigger(String trigger) {
        this.trigger = trigger;
        return this;
    }

    public long getTime() {
        return time;
    }

    public Event setTime(long time) {
        this.time = time;
        return this;
    }
}

/**
 * 被观察者的抽象类
 */
public class EventListener {

    protected Map<String,Event> events = new HashMap<String,Event>();

    public void addListener(String eventType, Object target, Method callback) {
        events.put(eventType,new Event(target,callback));
    }

    public void addListener(String eventType, Object target) {
        try {
            this.addListener(eventType, target, target.getClass().getMethod("on" + toUpperfirstCase(eventType),Event.class));
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }

    private String toUpperfirstCase(String eventType) {
        char[] chars = eventType.toCharArray();
        chars[0] -= 32;
        return String.valueOf(chars);
    }

    private void eventfire(Event event) {
        event.setSource(this);
        event.setTime(System.currentTimeMillis());
        try {
            if (event.getCallback() != null) {
                event.getCallback().invoke(event.getTarget(), event);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    // 触发
    protected void eventfire(String trigger) {
        if (!this.events.containsKey(trigger)) {
            return;
        }
        eventfire(this.events.get(trigger).setTrigger(trigger));
    }
}

/**
 * 具体被观察者
 */
public class Mouse extends EventListener{
    public void click(){
        System.out.println("单击鼠标回调");
        this.eventfire(MouseEventType.ON_CLICK);
    }

}

public class MouseEventType {
    public static final String  ON_CLICK = "click";
}

/**
 * 观察者
 */
public class MouseEventCallback {

    public void onClick(Event e) {
        System.out.println("触发鼠标单击事件");
    }
}

public class Test {
    public static void main(String[] args) {
        MouseEventCallback callback = new MouseEventCallback();
        Mouse mouse = new Mouse();

        mouse.addListener(MouseEventType.ON_CLICK,callback);

        mouse.click();
    }
}
```

#### 执行流程

1. 观察者

   1. 观察者类
      1. 具体执行方法（回调方法）

2. 被观察者

   1. 被观察者的抽象

      1. 添加观察者
         1. map存储 - key 事件类型，value Event（观察者，回调方法）
      2. 触发回调 （事件类型）
         1. 判断map中是否存在此事件类型
         2. 获取map的，回调方法 - > invoke (观察者,事件参数)

   2. mouse 继承被观察者抽象

      1. 触发回调 （事件类型）

      

      

### 应用

1. servlet - servletcontextlistener
2. spring-web contextloaderlistener



### 优点

1. 观察者和被观察者使松耦合的，符合依赖倒置原则
2. 分离了表示层（观察者）和数据逻辑层（被观察者），建立触发机制，使得数据的变化可以响应到多个表示层之上
3. 实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只有感兴趣的观察者可以接到通知



### 缺点

1. 观察者数量多，响应时间长
2. 事件呈线性通知，若一个观察者事件卡壳，那么会影响后续观察者接收该事件
3. 若观察者和被观察者存在循环依赖，循环调用，导致系统崩溃



