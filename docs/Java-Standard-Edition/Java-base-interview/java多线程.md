### 多个线程同时读写，读线程的数量量远远大于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？

reentrantlock中的readlock乐观锁适合读多写少的场景，每次获取数据的时候不会加锁，不用担心数据被修改。

### JAVA的AQS是否了了解，它是干嘛的？

它是JUC中reentrantlock的同步队列，当多个线程同时竞争同一把锁时，竞争失败的线程会进入到同步队列，当其中一个线程释放之后，将会唤醒head节点的下一个signal节点

### 除了synchronized关键字之外，你是怎么来保障线程安全的？

加JUC工具包中的reentrantlock进行锁粒度的控制

### 什么时候需要加volatile关键字？它能保证线程安全吗？

在多线程的情况下如果同时对某个数据进行更改，那么为了保证数据的可见性和安全性，需要用到volatile关键字

### 线程池内的线程如果全部忙，提交一个新的任务，会发生什么？队列列全部塞满了了之后，还是忙，再提交会发生什么？

根据自身电脑cpu的具体情况，进行合理扩容，同时调用addWork创建一个新的线程运行，如果超过最大线程数，会执行拒绝策略，抛出异常

### Tomcat本身的参数你一般会怎么调整？

删除不在用的web应用

减少web.xml的一些标签

静态文件可以放入ngnix，即可以删除默认servlet静态文件配置，jsp配置

在tomcat多集群的状态下，可以把manager 管理session放入redis进行管理

如果没有服务端主动向客户端推送消息，可以删除websocket包

connector 设置最大连接数

host 标签 autoDeploy 设置为false 要用一个线程来检查

context 标签 reloadable 设置为false 不会监视web-inf /classes或者web-inf/libs的文件的变化，而加载web应用

### synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？

代码块或者静态类两者锁的粒度不相同，代码块中可以锁住的对象是类级别也可以是方法级别，如果是类级别会保证锁的对象相互排斥，如果是方法级别，那么在创建多个对象的情况下，每个对象执行所属方法不会相互排斥



对象头，实例数据，对齐填充

对象头中的markword 所标记 01未被锁定，00 轻量，10重量，11 GC标记



### wait/notify/notifyAll方法需不需要被包含在synchronized块中？这是为什么？

需要，wait方法会释放锁阻塞当前的线程使其进入同步队列处于阻塞状态，所以需要通过synchronized获取到锁，notify会随机唤醒某个被阻塞的线程



### ExecutorService你一般是怎么用的？是每个service放一个还是一个项目里面放一个？有什么好处  

**怎么用**
线程池有几个应该看你具体要达到的目的来看
一般来说,如果有一套相同逻辑的多个任务的情况下,应用一个线程池是个好选择
如果项目中有多套不同的这种任务,那每套任务应该有一个线程池



**好处**

降低创建线程和销毁线程的性能开销
提高响应速度，当有新任务需要执行是不需要等待线程创建就可以立马执行
合理的设置线程池大小可以避免因为线程数超过硬件资源瓶颈带来的问题  