### 1 缓存雪崩

1. 现象：在大量key同一时间失效的情况下，进而使得大量请求，请求数据库，引起数据库负载甚至崩溃
2. 解决
   1. random
   2. 永不过期
   3. 预更新

### 2 缓存穿透

1. 现象：数据查询由于key的不存在，但又满足查询条件，会绕过redis进行数据库查询
2. 问题：数据量巨大进行查询，数据库负载较大
3. 解决：
   1. 布隆过滤器，判断是否存在，保证redis的使用
      1. 原理：利用哈希表映射到位图的特性（通过多次hash计算映射到位图）
      2. 缺点：当大数据量过滤时，会有hash值的碰撞，有一定的误判率
   2. 从DB中查询出来数据为空，也进行空数据的缓存，避免DB数据为空也每次都进行数据库查询；
   3. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；

### 3 缓存击穿

1. 现象：热点数据的key会在某些时间点被超高并发地访问会，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
2. 解决
   1.  设置热点数据不过期
   2.  加互斥锁

![缓存锁](https://img-blog.csdn.net/20180919143214879?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd0aWFvNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



​    说明

```
1. 缓存中有数据，直接走上述代码13行后就返回结果了
2. 缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。
3. 当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。
```

