## hash表

1. 定义

   1. > 通过hash函数来计算数据位置的一种结构

   2. > 通过hash函数将散列值映射数据结构的位置上（hash表）

   3. > 通过数组来进行表结构的存储

2. hash函数（散列函数）

   1. > 通过散列函数通过固定的算法将任意长度的数据转变为固定长度的数据，即散列值

   2. > MD5,SHA

3. hash冲突

   1. > 多个不同的key通过hash运算落到的是同一个数组的下标

   2. 解决方式

      1. > 线性探索（开放寻址法）, 相同位置进行累加，i+1，i+2 threadlocal

      2. > 链式地址法，相同位置通过链表往后延伸，hashmap

      3. > 再hash法，通过多次hash计算来获取位置，布隆过滤器bitMap

      4. > 建立公共溢出区，通过区分公共区溢出区，将与原基础表相同的hash值放入溢出区



## CHM的设计

1. 结构

   1. > jdk1.7：

      1. 将锁加到hash值冲突的数组下标，每个数组的节点为一个segment【段】，分段锁，每个分段为hashtable【hashentry】，如果hash相同再通过链式寻址
      2. 存在的问题
         1. 锁的粒度还是一个hashtable

   2. > jdk1.8

      1. 将锁加到hash值冲突的数组下标，此下标为一个node，锁的粒度更小，相同的hash也通过链表的方式存储，如果链表长度大于8，则会转化为红黑树，反之转变为链表，二分查找

2. 方法

   1. put
   1. 第一阶段（初始化）
         1. 第一次循环
            1. 初始化
               1. 构建一个16位的数据，负载因子为0.75
               2. cas不断循环，只允许一个线程进入，其他线程通过yield的方法释放cpu资源
         2. 第二次循环
            1. 添加数据到hash表中
      2. 第二阶段（hash冲突）
         1. hash发生冲突时
            1. 加锁
            2. 将冲突的值添加到hash的next节点
      3. 第三阶段（元素个数的统计和更新）
         1. AddCount添加元素个数（初始化阶段）
            1. 直接访问baseCount累加元素个数
            2. 找到cellcounter随机的某个下标位value= x+v表示记录元素个数
            3. 前面都失败进入 fullAndCount
         2. AddCount添加元素个数（元素更新）
            1. countcell为null
            2. 已经初始化，存在竞争，cas'进行更新
            3. 如果cas失败，触发countcell扩容

3. 扩容

   1. 元素个数大于阈值
   2. 如果此时正在扩容，扩容阶段进来的线程会协助扩容
      1. 一个线程负责16段
      2. 数据迁移
         1. 高低位
            1. 避免多次迁移
            2. 高位迁移
            3. 低位在原位置

