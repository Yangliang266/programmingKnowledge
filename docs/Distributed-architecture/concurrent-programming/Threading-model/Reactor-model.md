### 线程模型

> 数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，线程模型的不同，对性能的影响也非常大。

#### 事件驱动模型

通常，我们设计一个事件处理模型的程序有两种思路：

1. > 轮询方式：线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑；

2. > 事件驱动方式：发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中观察者模式的思路。

以 GUI 的逻辑处理为例，说明两种逻辑的不同：

1. > 轮询方式：线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑。

2. > 事件驱动方式：发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑。

   

   > 这里借用 O'Reilly 大神关于事件驱动模型解释图：

![img](https://yliang.oss-cn-shanghai.aliyuncs.com/img/programming/java/concurrent/768cee_720w.jpeg)

#### 主要包括 4 个基本组件：

1. > 事件队列（event queue）：接收事件的入口，存储待处理事件；

2. > 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元；

3. > 事件通道（event channel）：分发器与处理器之间的联系渠道；

4. > 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作。

可以看出，相对传统轮询模式，事件驱动有如下优点：

1. > 可扩展性好：分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑；

2. > 高性能：基于队列暂存事件，能方便并行异步处理事件。

   **netty就是运用的事件驱动模型**



#### Reactor 线程模型

> Reactor 是反应堆的意思，Reactor 模型是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。

> 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。

**Reactor 模型中有 2 个关键组成：**

> 1.Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；

> 2.Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。

![img](https://yliang.oss-cn-shanghai.aliyuncs.com/img/programming/java/concurrent/7235e1_720w.jpeg)

**取决于 Reactor 的数量和 Hanndler 线程数量的不同，Reactor 模型有 3 个变种：**

1. 单 Reactor 单线程；

2. 单 Reactor 多线程；

3. 主从 Reactor 多线程。

> 可以这样理解，Reactor 就是一个执行 while (true) { selector.select(); …} 循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。