## 线程死锁

### 产生条件

1. 互斥，共享资源x和y只能被一个线程使用
2. 占有且等待，线程t1已经取得共享资源x，在等待共享资源y的时候，不释放共享资源x
3. 不可抢占，其他线程不能强行抢占线程t1占有的资源
4. 循环等待，线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源，就是循环等待

### 解决方法

1. > 关键点：Lock可以让等待锁的线程响应中断，而synchronized不会，线程会一直等待下去。

2. > 占有且等待: 让进程在申请资源时，一次性申请所有需要用到的资源

   ```java
   public class Allocate {
       private List<Object> list = new ArrayList<>();
   
       synchronized boolean apply(Object from, Object to) {
           if (list.contains(from) || list.contains(to) ) {
               return false;
           }
           list.add(from);
           list.add(to);
           return true;
       }
   
       synchronized void free(Object from, Object to) {
           list.remove(from);
           list.remove(to);
       }
   }
   ```

   

   ```java
   public class Transf implements Runnable{
       private int amount;
       private Accout toAccount;
       private Accout fromAccount;
       private Allocate allocate;
   
       public Transf(int amount, Accout toAccount, Accout fromAccount,Allocate allocate) {
           this.amount = amount;
           this.toAccount = toAccount;
           this.fromAccount = fromAccount;
           this.allocate = allocate;
       }
   
       @Override
       public void run() {
           while (true) {
               // 统一分配资源
               if (allocate.apply(fromAccount,toAccount)) {
                   try {
                       synchronized (fromAccount) {
                           synchronized (toAccount) {
                               if (fromAccount.getBalance() >= amount) {
                                   fromAccount.debit(amount);
                                   toAccount.credit(amount);
                               }
                           }
                       }
                   } finally {
                       // 统一释放资源
                       allocate.free(fromAccount,toAccount);
                   }
               }
           }
   
   
       public static void main(String[] args) {
           Accout fromAccount14 = new Accout(1000000,"hello");
           Accout toAccount14 = new Accout(3000000,"world");
   
           Allocate allocate = new Allocate();
   
           Thread t1 = new Thread(new Transf(1,toAccount14,fromAccount14,allocate));
           Thread t2 = new Thread(new Transf(2,fromAccount14,toAccount14,allocate));
   
           t1.start();
           t2.start();
   
       }
   }
   ```

   

   

3. > 不可抢占: 通过lock.trylock方法，实现在获取不到锁之后，返回false，不存在抢占

   ```java
   private ReentrantLock lockFrom = new ReentrantLock();
   private ReentrantLock lockTo = new ReentrantLock(); 
   
   @Override
   public void run() {
       while (true) {
           if (lockFrom.tryLock) { // true或者false
               if (lockTo.tryLock) { // true或者false
                   if (fromAccount.getBalance() >= amount) {
                       fromAccount.debit(amount);
                       toAccount.credit(amount);
                   }
               }
           }
       }
   }
   ```

4. > 循环等待: 按照顺序执行

   ```java
   @Override
   public void run() {
       Accout left = null;
       Accout right = null;
       if (fromAccount.hashCode() > toAccount.hashCode()) {
           left = toAccount;
           right = fromAccount;
       }
       while (true) {
           synchronized (left) {
               synchronized (right) {
                   if (fromAccount.getBalance() >= amount) {
                       fromAccount.debit(amount);
                       toAccount.credit(amount);
                   }
               }
           }
       }
   }
   ```

   

## 线程的隔离

