## 线程死锁

Java产生死锁的一个简单例子
思路是创建两个字符串a和b，再创建两个线程A和B，让每个线程都用synchronized锁住字符串（A先锁a，再去锁b；B先锁b，再锁a），如果A锁住a，B锁住b，A就没办法锁住b，B也没办法锁住a，这时就陷入了死锁。直接贴代码：

复制代码
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }    
}
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
复制代码
运行的结果如图所示：



可以看到，Lock1获取obj1，Lock2获取obj2，但是它们都没有办法再获取另外一个obj，因为它们都在等待对方先释放锁，这时就是死锁。

 

如果我们只运行Lock1呢？修改一下main函数，把线程b注释掉。

复制代码
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        //Thread b = new Thread(new Lock2());
        a.start();
        //b.start();
    }
}
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
复制代码
运行结果为：


由于没有其它线程和Lock1争夺obj1和obj2，Lock1可以不断地循环获取并释放它们，这时没有死锁。

### 产生条件

1. 互斥，共享资源x和y只能被一个线程使用
2. 占有且等待，线程t1已经取得共享资源x，在等待共享资源y的时候，不释放共享资源x
3. 不可抢占，其他线程不能强行抢占线程t1占有的资源
4. 循环等待，线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源，就是循环等待

### 解决方法

1. > 关键点：Lock可以让等待锁的线程响应中断，而synchronized不会，线程会一直等待下去。

2. > 占有且等待: 让进程在申请资源时，一次性申请所有需要用到的资源

   ```java
   public class Allocate {
       private List<Object> list = new ArrayList<>();
   
       synchronized boolean apply(Object from, Object to) {
           if (list.contains(from) || list.contains(to) ) {
               return false;
           }
           list.add(from);
           list.add(to);
           return true;
       }
   
       synchronized void free(Object from, Object to) {
           list.remove(from);
           list.remove(to);
       }
   }
   ```

   

   ```java
   public class Transf implements Runnable{
       private int amount;
       private Accout toAccount;
       private Accout fromAccount;
       private Allocate allocate;
   
       public Transf(int amount, Accout toAccount, Accout fromAccount,Allocate allocate) {
           this.amount = amount;
           this.toAccount = toAccount;
           this.fromAccount = fromAccount;
           this.allocate = allocate;
       }
   
       @Override
       public void run() {
           while (true) {
               // 统一分配资源
               if (allocate.apply(fromAccount,toAccount)) {
                   try {
                       synchronized (fromAccount) {
                           synchronized (toAccount) {
                               if (fromAccount.getBalance() >= amount) {
                                   fromAccount.debit(amount);
                                   toAccount.credit(amount);
                               }
                           }
                       }
                   } finally {
                       // 统一释放资源
                       allocate.free(fromAccount,toAccount);
                   }
               }
           }
   
   
       public static void main(String[] args) {
           Accout fromAccount14 = new Accout(1000000,"hello");
           Accout toAccount14 = new Accout(3000000,"world");
   
           Allocate allocate = new Allocate();
   
           Thread t1 = new Thread(new Transf(1,toAccount14,fromAccount14,allocate));
           Thread t2 = new Thread(new Transf(2,fromAccount14,toAccount14,allocate));
   
           t1.start();
           t2.start();
   
       }
   }
   ```

   

   

3. > 不可抢占: 通过lock.trylock方法，实现在获取不到锁之后，返回false，不存在抢占

   ```java
   private ReentrantLock lockFrom = new ReentrantLock();
   private ReentrantLock lockTo = new ReentrantLock(); 
   
   @Override
   public void run() {
       while (true) {
           if (lockFrom.tryLock) { // true或者false
               if (lockTo.tryLock) { // true或者false
                   if (fromAccount.getBalance() >= amount) {
                       fromAccount.debit(amount);
                       toAccount.credit(amount);
                   }
               }
           }
       }
   }
   ```

4. > 循环等待: 按照顺序执行

   ```java
   @Override
   public void run() {
       Accout left = null;
       Accout right = null;
       if (fromAccount.hashCode() > toAccount.hashCode()) {
           left = toAccount;
           right = fromAccount;
       }
       while (true) {
           synchronized (left) {
               synchronized (right) {
                   if (fromAccount.getBalance() >= amount) {
                       fromAccount.debit(amount);
                       toAccount.credit(amount);
                   }
               }
           }
       }
   }
   ```

   

## 线程的隔离

