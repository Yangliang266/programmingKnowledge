## 硬件问题

### 计算机发展带来的问题

1. cpu，内存，磁盘之间的速度快慢不一，会影响cpu的资源不能充分利用
2. 引入高速缓存，存放常用指令与数据，进一步提高cpu的利用率

### 高速缓存带来的问题

1. 多线程如果同时访问并使用修改缓存中的数据会导致数据的不一致，即数据的可见性

### 解决方案

1. 引入总线索

   1. > 由于总线锁的作用是，在一个线程访问时，对其他线程进行阻塞，会导致性能的下降

2. 引入缓存索

   1. 缓存锁是在对缓存中的数据更新到内存中，进行加锁。相对于总线锁来说缓存锁进一步控制了锁的粒度

   2. 遵循的协议

      1. > MESI  协议

         1. M: 表示修改状态，会通知其他线程处于失效状态
         2. E: 表示独占状态，即当前仅有此线程在使用共享变量
         3. S: 表示共享状态，即当前有多个线程都在使用共享变量
         4. I: 表示失效状态，在其他线程修改共享变量时，此线程变量处于失效状态

      2. MESI 协议带来的问题

         <img src="https://raw.githubusercontent.com/YangLiang-SoftWise/images/master/img/MESI协议出现的问题.jpg" style="zoom: 50%;" />

      3. 指令重排序

         1. 重排序的机制

            1. 不改变程序执行结果
            2. 如果两个指令存在依赖关系，不允许重排序

         2. 代码执行时重排序过程

            1. 编译器
               1. 编译器优化重排序
            2. cpu层面
               1. 指令级并行重排序
               2. 内存系统重排序

         3. 解决方式: 提供内存屏障

            1. > store : 保证在执行下个指令之前，把修改的值写入到内存

            2. > load：保证在执行下个指令之前，读取内存中最新的值

            3. > fence：全屏障

         4. 指令重排序的优缺点

            1. > 优点：优化了缓存行的使用，避免再次从内存中取值，使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率。
CPU使用了流水线技术，也就是说，CPU有多个功能单元（如获取、解码、运算和结果），一条指令也分为多个单元，那么第一条指令执行还没完毕，就可以执行第二条指令，前提是这两条指令功能单元相同或类似，所以一般可以通过指令重排使得具有相似功能单元的指令接连执行来减少流水线中断的情况。
   
            2. > 缺点：引起数据的可见性，线程之间数据不一致



## 软件层面

### Java内存模型的出现

1. **出现背景** 
   
   1. > 由于多系统的不同架构和cpu的差异所表现出的状态都需要统一解决，解决线程的安全性
   
2. **概念** 

   1. > 在共享内存中，多线程读写的操作规范

3. **特点**

   1. 表现与模型
      1. 底层硬件的抽象到java层面表现
      2. 并不是真实存在的模型
   2. 问题的解决
      1. 提供了有序性和可见性的解决方案
      2. 并未解决底层的可见性问题，而是提供一些高级指令来实现
   3. 实现方式
      1. 把不同平台的指令抽象化，进行统一管理，jvm跨平台



## 可见性的解决

1. 解决问题所在

   1. 防止指令重排序
   2. 禁用高速缓存
   3. 使用内存屏障

2. JMM层面提供高级指令解决

   1. volidate

      1. lock的汇编指令（store,load,fence总称）保证可见性

   2. 内存屏障指令

      1. load1 loadload load2 

         1. > 1先加载内存指令后，2以及之后的指令才能加载

      2. store1 storestore store2

         1. > 1先刷新到内存后，2以及之后的指令才能刷新到内存

      3. store1 storeload load2

         1. > 1先刷新到内存后，2以及之后的指令才能加载

      4. load1 loadstore store2

         1. > 1先加载内存指令后，2以及之后的指令才能刷新到内存

3. Happens—Before模型解决

   1. **程序顺序规则（as-if-serial语义）**
      1. 单线程执行的指令是有序的
      2. 不代表指令顺序，只要不影响最终结果
      3. a happens-before b 
         1. a的结果对b可见
      4. b happens-before c
         1. b的结果对c可见
   2. **传递性规则**
      1. a happens-before b 
      2. b happens-before c
      3. a happens-before c
   3. **volatitle规则**
      1. 写操作happens-before读操作
   4. **监视器锁规则**
      1. synchornized
   5. **start规则**
      1. a happens-before thread.start()
   6. **join规则**
      1. 保证结果对后续指令可见
      2. 使用了synchornized锁

