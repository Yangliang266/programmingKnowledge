## 硬件问题

### 计算机发展带来的问题

1. cpu，内存，磁盘之间的速度快慢不一，会影响cpu的资源不能充分利用
2. 引入高速缓存，存放常用指令与数据，进一步提高cpu的利用率

### 高速缓存带来的问题

1. 多线程如果同时访问并使用修改缓存中的数据会导致数据的不一致，即数据的可见性

### 解决方案

1. 引入总线索

   1. > 由于总线锁的作用是，在一个线程访问时，对其他线程进行阻塞，会导致性能的下降

2. 引入缓存索

   1. 缓存锁是在对缓存中的数据更新到内存中，进行加锁。相对于总线锁来说缓存锁进一步控制了锁的粒度

   2. 遵循的协议

      1. > MESI  协议

         1. M: 表示修改状态，会通知其他线程处于失效状态
         2. E: 表示独占状态，即当前仅有此线程在使用共享变量
         3. S: 表示共享状态，即当前有多个线程都在使用共享变量
         4. I: 表示失效状态，在其他线程修改共享变量时，此线程变量处于失效状态

      2. MESI 协议带来的问题

         <img src="https://raw.githubusercontent.com/YangLiang-SoftWise/images/master/img/MESI协议出现的问题.jpg" style="zoom: 50%;" />

      3. 指令重排序

         1. 重排序的机制

            1. 不改变程序执行结果
            2. 如果两个指令存在依赖关系，不允许重排序

         2. 代码执行时重排序过程

            1. 编译器
               1. 编译器优化重排序
            2. cpu层面
               1. 指令级并行重排序
               2. 内存系统重排序

         3. 解决方式: 提供内存屏障

            1. > store : 保证在执行下个指令之前，把修改的值写入到内存

            2. > load：保证在执行下个指令之前，读取内存中最新的值

            3. > fence：全屏障

         4. 指令重排序的优缺点

            1. > 优点：优化了缓存行的使用，避免再次从内存中取值

            2. > 缺点：引起数据的可见性，线程之间数据不一致



## 软件层面

### Java内存模型的出现

1. **出现背景** 
   
   1. > 由于多系统的不同架构和cpu的差异所表现出的状态都需要统一解决，解决线程的安全性
   
2. **概念** 

   1. > 在共享内存中，多线程读写的操作规范

3. **特点**

   1. 表现与模型
      1. 底层硬件的抽象到java层面表现
      2. 并不是真实存在的模型
   2. 问题的解决
      1. 提供了有序性和可见性的解决方案
      2. 并未解决底层的可见性问题，而是提供一些高级指令来实现
   3. 实现方式
      1. 把不同平台的指令抽象化，进行统一管理，jvm跨平台



## 可见性的解决

1. 解决问题所在

   1. 防止指令重排序
   2. 禁用高速缓存
   3. 使用内存屏障

2. JMM层面提供高级指令解决

   1. volatitile

      1. lock的汇编指令（store,load,fence总称）保证可见性

   2. 内存屏障指令

      1. load1 loadload load2 

         1. > 1先加载内存指令后，2以及之后的指令才能加载

      2. store1 storestore store2

         1. > 1先刷新到内存后，2以及之后的指令才能刷新到内存

      3. store1 storeload load2

         1. > 1先刷新到内存后，2以及之后的指令才能加载

      4. load1 loadstore store2

         1. > 1先加载内存指令后，2以及之后的指令才能刷新到内存

3. Happens—Before模型解决

   1. **程序顺序规则（as-if-serial语义）**
      1. 单线程执行的指令是有序的
      2. 不代表指令顺序，只要不影响最终结果
      3. a happens-before b 
         1. a的结果对b可见
      4. b happens-before c
         1. b的结果对c可见
   2. **传递性规则**
      1. a happens-before b 
      2. b happens-before c
      3. a happens-before c
   3. **volatitle规则**
      1. 写操作happens-before读操作
   4. **监视器锁规则**
      1. synchornized
   5. **start规则**
      1. a happens-before thread.start()
   6. **join规则**
      1. 保证结果对后续指令可见
      2. 使用了synchornized锁

