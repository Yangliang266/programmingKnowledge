## 事务和锁

### 事务的必要性

#### 事务的特征

##### 原子性

> 整个事务中的操作要么全部成功，要么全部失败

##### 隔离性

> 一个事务在提交之前的操作对于另一个事务可见，取决这个事务设置的隔离级别

##### 一致性

> 事务执行前后的数据保持一致

##### 持久性

> 事务提交后，数据所做的修改将被保存



#### 事务的开启

begin 开始

commit/rollback 结束



### 事务的隔离级别

> 事务的隔离是通过的锁的机制来实现的

#### 隔离级别的必要

1. 脏读

   > 事务A读取了事务B的未提交的数据并进行操作，事务B进行回滚，即事务A读取的数据就是脏数据

2. 不可重复读

   > 事务A在事务B进行修改之前和修改之后分别读了一次，两次读的结果不一致

3. 幻读

   > 事务A读到了其他事务新增的数据

   

#### 解决方案

##### 读未提交

> 事务b所做的修改并未提交，另一个事务也能看到它的修改的数据

##### 读已提交

> 未提交的写事务将禁止其他事务访问，但会出现事务a读取， 事务b修改，事务a在读取时，数据已经更改

##### 可重复读

> 事务a还没结束，事务b访问同一个数据，即使事务b进行修改，事务a两次读到的数据都是一样的

##### 序列化

> 事务只能一个接着一个的执行，不能并发操作



#### mysql的默认执行策略

>  可重复读，一致性非锁定读的机制，当前行被施加了排他锁，当需要读取行数据时，不会等待锁的释放，而是会读取一个快照

##### mvcc 快照（事务日志所对应的undo段来实现的）

![img](https://raw.githubusercontent.com/YangLiang-SoftWise/images/master/img/索引10.png)

   

#### 锁机制介绍

> 目的：保证数据的一致性

##### 锁机制

1. 行级锁类型

   1. 共享锁，读锁s

      > 允许持有该锁的事务读取行

   2. 排他锁，写锁x

      > 允许持有该锁的事务更新或者删除行

   3. 流程

      1. 如果事务a，在r行持有s锁，立即授予事务b于s锁，但是x锁不能立即授予
      2. 如果事务a，在r行持有x锁，不能立即授予事务b于r行上任何类型的锁

2. 根据锁定范围的不同，行锁的种类

   1. 记录锁：唯一索引，精准查询

   2. 间隙锁：锁定一个范围

   3. 临键锁：包含记录和区间，由于遵循左开右闭，时记录锁和间隙锁的组合

      <img src="https://raw.githubusercontent.com/YangLiang-SoftWise/images/master/img/索引9.png" alt="img" style="zoom:67%;" />

3. 表级锁

   1. 意向锁

      > 目的：为了让行级锁和表级锁共存，防止ddl和dml的并发问题

      1. 意向共享锁：事务想要获得一张表中的某几行共享锁
      2. 意向排他锁：事务想要获得一张表中的某几行排他锁

   

4. 行锁和表锁注意点

   > 行级锁通常是给索引上的索引项加锁来实现
   >
   > 不通过索引查询时，使用的表级锁



##### 锁等待

> 一个事务中产生的锁，其他事务需要等待上一个事务释放锁才能占用该资源



##### 死锁

> 当两个或者多个事务互相持有对方需要的锁，就会产生死锁

###### 解决方法

1. 不同程序并发存取多个表或者涉及多个行记录，保证以相同的顺序访问
2. 将大事务分解成多个小事务
3. 在同一个事务中，尽可能一次性锁定所需要的所有资源
4. 为表添加合理的索引
5. 容易产生死锁的业务部分，升级锁的粒度，通过表锁定减少死锁的发生




