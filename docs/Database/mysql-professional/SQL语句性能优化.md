## sql语句性能优化

### 索引概况

<img src="https://raw.githubusercontent.com/YangLiang266/images/master/img/索引1.png" alt="img" style="zoom:80%;" />



#### 索引的本质

> 索引可以看作是一个数据结构
>
> 具体采用B+tree的数据结构，多路平衡查找树

 #### 索引存在的必要性

> 简而言之就是在查询数据时减少磁盘的io消耗

##### 1 为什么要有内存管理？

> 我们知道，一个进程完成他的功能，需要访问磁盘加载数据到内存然后等待进入 cpu 运算，因为数据量大小远远大于内存大小。因此提出虚拟内存概念。虚拟内存就是将程序用到的数据进行划分，暂时用不到的放到磁盘里，用到的放到内存里，操作系统中总是运行着不止一个进程，各个进程有优先级顺序，所以存在进程调度问题，进程的每次调度都会导致内存和磁盘数据置换，段式内存管理页式内存管理都是基于虚拟内存概念的具体内存管理解决方案。

 

##### 2 什么是页式内存管理？

> 虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。

> 分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像 Linux 中 ext 文件系统将磁盘分成若干个 Block 一样，这样做是分别是为了提高内存和磁盘的利用率。

 

##### 3 页的大小为什么是 4K?

> CPU 位数准确地说应该是 CPU 一次能够并行处理的数据宽度，一般就是指数据总线宽度。

 

##### 4 mysql 索引和页的关系

> B-tree，B 是 balance，一般用于数据库的索引。使用 B-tree 结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。而 B+tree 是 B-tree 的一个变种，MySQL 就普遍使用 B+tree 实现其索引结构。　　
> 　　一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。
> 　　为了达到这个目的，磁盘按需读取，**要求每次都会预读的长度一般为页的整数倍。而且数据库系统将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。**每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。并把 B-tree 中的 m 值设的非常大，就会让树的高度降低，有利于一次完全载入。



#### 索引的结构特点

1. 非叶子节点存储的是关键字引用
2. 叶子节点存储的是具体的数据
3. 叶子节点之间是以链表的形式存在的，前面的数据关联后面的数据，指针指向（不是数据的指向而是引用的指向），有序
4. 子节点遵循左闭右开原则

#### 索引的优点

1. 它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。B Tree 解决的两大问题 是什么？（每个节点存储更多关键字；路数更多
2. 扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree 拿到所有的数据），磁盘块（页）之间是通过双向链表联系，数据之间使用单向链表链接
3. B+Tree 的磁盘读写能力相对于 B Tree 来说更强（根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
4. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
5. 效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的）

### 索引的分类

#### 主键索引和辅助索引

> **InnoDB 使用的是聚簇索引**，将主键组织到一棵 B + 树中，而行数据就储存在叶子节点上，若使用 "where id = 14" 这样的条件查找主键，则按照 B + 树的检索算法即可查找到对应的叶节点，之后获得行数据。若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B + 树中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B + 树种再执行一次 B + 树检索操作，最终到达叶子节点即可获取整行数据。

<img src="https://raw.githubusercontent.com/YangLiang-SoftWise/images/master/img/索引8.png" alt="img" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/YangLiang266/images/master/img/索引7.png" alt="img" style="zoom: 67%;" />



#### 联合索引

##### 创建

> alter table test add index name_age_address(name,age,address); 

##### 定义

> 将多个索引定义到一起

##### 使用规则

1. 最左匹配

   > - [x] select age from test  where name
   > - [x] select age from test  where name  order by age
   > - [ ] select age from test where age 
   > - [ ] select age from test where name order by address

2. 联合索引(a, b)是根据a, b进行排序（先根据a排序，如果a相同则根据b排序）

##### 注意点

1. 当已经有了(a,b)字段的索引，一般就不需要再单独在a上建立索引了



#### 覆盖索引

##### 非覆盖索引

`select * from T where k between 3 and 5;`

则这条SQL语句的执行流程如下：

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；
2. 再到 ID 索引树查到 ID=300 对应的 R3；
3. 在 k 索引树取下一个值 k=5，取得 ID=500；
4. 再回到 ID 索引树查到 ID=500 对应的 R4；
5. 在 k 索引树取下一个值k=6，不满足条件，循环结束。

> 在这个过程中，回到主键索引树的过程，称为回表。在这个例子中，**由于查询的结果是所有字段，所需要的数据只有主键上才有，所以不得不回表**。但如果执行的语句是下面这样的，注意！这里查询的结果只是“ID”（恰好是主键），而不是所有字段了。



##### 覆盖索引

`select ID from T where k between 3 and 5;`

> 由于查询的值是ID，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里，索引k已经“覆盖了”我们的查询需求，也就是说辅助索引已经覆盖了我们的查询需求，故称为**覆盖索引**。

###### 适用场景

> 针对某些统计问题时，覆盖索引也能发挥用处

`select count(*) from T;`

> 如果没有对字段k设置索引，那么只能是通过聚簇索引来计算；如果对字段k设置了索引，那么，由于聚簇索引的叶结点存放的是整行记录的所有信息，而辅助索引的叶结点只存放主键，两者相比，对于一页内存，显然辅助索引能够存放的节点更多，意味着辅助索引可以减少IO次数，从而更快的计算出count(*)的值。



###### 覆盖索引特点

> 覆盖索引就是从辅助索引中就能**直接**得到查询结果，而不需要回表到聚簇索引中进行再次查询，所以可以减少搜索次数（不需要从辅助索引树回表到聚簇索引树），或者说减少IO操作（通过辅助索引树可以一次性从磁盘载入更多节点），从而提升性能。



#### 索引下推（ICP）

##### 定义

> 可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数

##### 优化过程

什么是索引下推（Index Condition Pushdown，ICP）呢？假设有这么个需求，查询表中“名字第一个字是张，性别男，年龄为10岁的所有记录”。那么，查询语句是这么写的：

```
mysq> select * from tuser where name like '张 %' and age=10 and ismale=1;
```

根据前面说的“最左前缀原则”，该语句在搜索索引树的时候，**只能**匹配到名字第一个字是‘张’的记录（即记录ID3），接下来是怎么处理的呢？当然就是从ID3开始，逐个回表，到主键索引上找出相应的记录，再比对age和ismale这两个字段的值是否符合。



下面图1、图2分别展示这两种情况。
<img src="https://yliang.oss-cn-shanghai.aliyuncs.com/img/programming/frame/mybatis/1442950-20190814212244261-1117817291.jpg" alt="img" style="zoom:50%;" />
（图1）

<img src="https://yliang.oss-cn-shanghai.aliyuncs.com/img/programming/frame/mybatis/1442950-20190814212252775-2029895777.jpg" alt="img" style="zoom:50%;" />
（图2）

图 1 中，在 (name,age) 索引里面我特意去掉了 age 的值，**这个过程 InnoDB 并不会去看 age 的值**，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。

图 2 跟图 1 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。

##### 总结

如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能



#### 索引使用原则

1. 表一定要有主键，显示定义且采用与业务无关的列，自增
2. 对于经常被查询的列，表连接，排序分组的列创建索引
3. 离散值越高选择性越高，反之不适合创建
4. 组合索引，一般把把选择性高的放在前面，不超过5个
5. 合理利用覆盖索引，即二级索引中的叶子节点所包含的数据就是所需要查询的数据
6. 不建议在频繁需要更新的字段上建立索引
7. 单表的索引数量不超过5个
8. 避免在where条件进行索引列的计算或者使用函数，否则将进行全表扫描
9. join查询，被join的字段必须类型相同并建立索引，join字段类型不一致导致全表扫描
10. 隐式类型转换会使得索引失效