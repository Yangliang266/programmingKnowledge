### 开闭原则

1. > 核心：面向抽象编程

2. > 类，模块，方法对扩展开放对修改关闭

3. > 优点: 提高软件的可复用性和可维护性



### 依赖倒置原则

1. > 定义：高层模块不依赖底层模块，二者都依赖抽象，细节依赖抽象，针对接口编程

2. > 优点：减少类的耦合性提高系统的稳定性，提高代码的可读性和可维护性

3. > 应用：spring的DI注入

   ```java
   public interface ICourse {
       void study();
   }
   
   JavaCourse extends ICourse
   PythonCourse extends ICourse
   
   
   
   // v1
   public class Jetty{
       public void study(ICourse icourse) {
           icourse.study();
       }
   }
   
   Jetty jetty = new Jetty();
   jetty.study(new JavaCourse())
   jetty.study(new PythonCourse())   
       
   // v2 
   public class Jetty{
       private ICourse icourse;
       
       public void setICourse(ICourse icourse){
           this.icourse = icourse;
       }
       
       public void study() {
           icourse.study();
       }
   }
   
   Jetty jetty = new Jetty();
   // 单例
   jetty.setICourse(new JavaCourse());
   jetty.study();
   
   ```

### 单一职责原则

1. > 定义：不存在多于导致一个导致类变更的原因

2. > 一个类，接口，方法只负责一项职能

3. > 优点:：降低类的复杂度，提高类的可读性

   ```java
   // 接口职能隔离
   public interface IcourseInfo {
       void studyCourse();
       void refundCourse();
   }
   
   public interface IcourseManager {
       String getCourseName();
       byte[] getCoursevideo();
   }
   
   public class CourseImp implements IcourseInfo, IcourseManager {
       @Override
       public String getCourseName() {
           return null;
       }
   
       @Override
       public byte[] getCoursevideo() {
           return new byte[0];
       }
   
       @Override
       public void studyCourse() {
   
       }
   
       @Override
       public void refundCourse() {
   
       }
   }
   
   // 类职能隔离
   public class Live {
       public void study(String courseName) {
           System.out.println("不能快进");
       }
   }
   
   public class Replay {
       public void study(String courseName) {
           System.out.println("可以快进");
       }
   }
   ```

   ### 接口隔离原则

   1. > 用多个专用的接口

   2. > 高耦合低内聚

      ```java
      public interface IEatAnimal {
          void eat();
      }
      public interface IFlyAnimal {
          void fly();
      }
      public interface ISwimAnimal {
          void swim();
      }
      public class Dog implements IEatAnimal, ISwimAnimal {
          @Override
          public void eat() {
      
          }
      
          @Override
          public void swim() {
      
          }
      }
      public class Bird implements IEatAnimal,IFlyAnimal {
          @Override
          public void eat() {
      
          }
      
          @Override
          public void fly() {
      
          }
      }
      ```

      

### 迪米特法则（最少知道原则）

1. >  一个对象应该对其他对象保持最少的了解,降低类和类之家的耦合

   ```java
   public class Course {
   }
   
   public class Employee {
       private List courseList = new ArrayList();
   
       public void courseNum() {
           for (int i = 0; i < 10; i++) {
               courseList.add(new Course());
           }
           System.out.println(courseList.size());
       }
   }
   
   public class TeamLeader {
       public void Course2EmployeeAndcoursenum(Employee employee) {
           employee.courseNum();
       }
   
       public static void main(String[] args) {
           TeamLeader teamLeader = new TeamLeader();
           teamLeader.Course2EmployeeAndcoursenum(new Employee());
       }
   }
   ```



### 里氏替换原则

1. 子类可以扩展父类的功能，但不能更改父类的方法
2. 子类可以实现父类的抽象方法，不能覆盖父类的非抽象方法
3. 子类可以增加自己特有的方法
4. 子类重载父类方法时，方法输入的参数要比父类宽松
5. 子类的方法实现父类的方法（重写，重载，抽象方法的实现）的后置条件（方法的输出，返回值）要比父类严格或相等



### 合成复用原则

1. > 定义

   1. 尽量的使用对象的组合，聚合，而不是继承来达到组件复用的目的
   2. 聚合has-a和组合contains-a

2. > 优点：使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较小

   ​	