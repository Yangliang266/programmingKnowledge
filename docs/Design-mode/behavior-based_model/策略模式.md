### 定义 

> 将定义的算法，分别进行分装，让他们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户，避免多重if，switch



### 适用场景

1. 系统中有很多类，区别仅在于它们的行为不同
2. 一个系统需要动态的在几种算法选择一种
3. 需要屏蔽算法规则



### 实例

```java
public interface Promotion {
    void doPromotion();
}

public class CardDiscount implements Promotion {
    @Override
    public void doPromation() {
        System.out.println("优惠卷优惠");
    }
}

public class EmptyStategy implements Promotion {
    @Override
    public void doPromation() {
        System.out.println("无打折优惠");
    }
}

public class FestivalDiscount implements Promotion {
    @Override
    public void doPromotion() {
        System.out.println("节日优惠");
    }
}

public class GroupDiscount implements Promotion {
    @Override
    public void doPromotion() {
        System.out.println("成团打折");
    }
}


public class PromotionStrategyFactory {
     public interface PromotionKeys {
         String CARD = "card";
         String FESTIVAL = "festival";
         String GROUP = "group";
     }

     private static Map<String,Promotion> ptkeys = new HashMap<String,Promotion>();

     static {
         ptkeys.put(PromotionKeys.CARD,new CardDiscount());
         ptkeys.put(PromotionKeys.FESTIVAL, new FestivalDiscount());
         ptkeys.put(PromotionKeys.GROUP, new GroupDiscount());
     }

     private static final Promotion EMPTY = new EmptyStategy();

     public static Promotion getPromotionStrategy(String promotionKeys) {
         Promotion pmt = ptkeys.get(promotionKeys);
         return pmt == null ? EMPTY : pmt;
     }

     public static Set<String> getPromotionKeys() {
         return ptkeys.keySet();
     }

}


public class Test {
    public static void main(String[] args) {
        PromotionStrategyFactory.getPromotionKeys();
        String key = "group";
        PromotionStrategyFactory.getPromotionStrategy(key).doPromotion();
    }
}
```



```JAVA
public class MsgResult {
    private int code;
    private String msg;
    private String data;

    public MsgResult(int code, String msg, String data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    @Override
    public String toString() {
        return "MsgResult{" +
                "code=" + code +
                ", msg='" + msg + '\'' +
                ", data='" + data + '\'' +
                '}';
    }
}

public abstract class BasePay {
    public abstract String getName();

    public abstract double queryAmount(int uid);


    public MsgResult pay(int uid, double amount) {
        if (queryAmount(uid) > amount) {
            return new MsgResult(500,"success","支付金额" + amount);
        }
        return  new MsgResult(200,"error","金额不足");
    }
}

public class AliyPay extends BasePay {
    @Override
    public String getName() {
        return "阿里支付";
    }

    @Override
    public double queryAmount(int uid) {
        return 500;
    }
}

public class JdPay extends BasePay {
    @Override
    public String getName() {
        return "京东支付";
    }

    @Override
    public double queryAmount(int uid) {
        return 400;
    }
}

public class QqPay extends BasePay {
    @Override
    public String getName() {
        return "qq支付";
    }

    @Override
    public double queryAmount(int uid) {
        return 300;
    }
}

public class WechatPay extends BasePay {
    @Override
    public String getName() {
        return "微信支付";
    }

    @Override
    public double queryAmount(int uid) {
        return 100;
    }
}

public class PayStrategy {

    public static final String ALIPAY = "AliPay";
    public static final String JDPAY = "JdPay";
    public static final String WECHATPAY = "WechatPay";
    public static final String QQPAY = "QqPay";
    public static final String DEFALUTPAY = ALIPAY;

    private static Map<String, BasePay> payMap = new HashMap<String, BasePay>();

    static {
        payMap.put(ALIPAY,new AliyPay());
        payMap.put(JDPAY,new JdPay());
        payMap.put(WECHATPAY,new WechatPay());
        payMap.put(QQPAY,new QqPay());
    }

    public static BasePay getPay(String payKey) {
        if (!payMap.containsKey(payKey)) {
            return payMap.get(DEFALUTPAY);
        }
        return payMap.get(payKey);
    }

}

public class Order {
    private int uid;
    private int orderId;
    private double amount;

    public Order(int uid, int orderId, double amount) {
        this.uid = uid;
        this.orderId = orderId;
        this.amount = amount;
    }

    public MsgResult pay() {
        return pay(PayStrategy.DEFALUTPAY);
    }

    public MsgResult pay(String key) {
        BasePay basePay = PayStrategy.getPay(key);
        System.out.println("本次交易方式为：" + basePay.getName());
        System.out.println("本次交易金额为：" + amount);
        return basePay.pay(uid,amount);
    }
}

public class Test {
    public static void main(String[] args) {
        Order order = new Order(111232312,21321323,100);
        System.out.println(order.pay("JdPay"));
    }
}
```



### 应用

1. spring bean- Instantiantionstrategy
2. comparation sort - Tree map
3. spring core - Resource



### 优点

1. 符合开闭原则
2. 避免使用多重条件转移语句
3. 提高算法的保密性和安全性



### 缺点

1. 客户端必须知道所有的策略，自行决定使用哪个策略
2. 代码中会产生很多的策略类，增加维护难度

