### 定义

> 负责任务的调度和分配，将任务的分配和执行分离开来，可看作使特殊情况下的静态代理的全权代理,不属于gof23



### 适用场景

1. 委派模式本身不知如何处理一个任务，把请求交个其他对象来处理

2. 实现程序的解耦

   

### 实例

```java
// 执行者
public class Boss {
    public void commond(String task,Leader leader) {
        leader.doing(task);
    }
}

// 分发的目标者
public interface Employee {
    void doing(String task);
}
public class EmployeeA implements Employee {
    private  String goodAt = "海报";
    @Override
    public void doing(String task) {
        System.out.println("员工A，擅长" + task);
    }
}
public class EmployeeB implements Employee {
    private  String goodAt = "编程";
    @Override
    public void doing(String task) {
        System.out.println("员工A，擅长" + task);
    }
}

// 策略算法中转分配，不做其他处理，非全能类
public class Leader implements Employee {
    private Map<String, Employee> employeeMap = new HashMap<String, Employee>();

    public Leader() {
        employeeMap.put("海报", new EmployeeA());
        employeeMap.put("爬虫", new EmployeeB());
    }

    @Override
    public void doing(String task) {
        if (!employeeMap.containsKey(task)) {
            System.out.println("无匹配任务");
            return;
        }
        employeeMap.get(task).doing(task);
    }
}
```



### 源码应用

1. classloader jvm

2. method 反射

3. dispatcher servlet

   

### 与其他模式区别

1. 代理模式
   1. 代理为结构型，增强，注重过程
   2. 委派为行为型，分配，注重结构
   3. 是一种特殊的静态代理，相当于全权代理



### 优点

1. 能够将一个大型的任务进行细化，统一进行管理这些子任务的完成情况实现任务的跟进，加快任务的执行效率

   

### 缺点

1. 需要更具任务的复杂程度进行不同的更改，在任务比较多的情况下，可能需要多重委派，容易造成混乱